import{S as Q,i as R,s as T,C as B,w as W,x as X,y as Y,z as Z,A as ee,f as te,t as se,B as oe,V as K,l as h,r as a,a as M,m as p,n as f,u as i,h as l,c as N,p as ae,b as A,F as s,E as ie}from"./index-a4e35989.js";import{P as ne}from"./Page-0e14739b.js";import"./masthead.module-88889344.js";function le(g){let e,c,d,n,t,_,m,C,D,O,o,k,E,I,P,y,S,j,b,z,L,w,U,q;return{c(){e=h("h2"),c=a("Possible issues"),d=M(),n=h("ul"),t=h("li"),_=a("Slides should not have "),m=h("code"),C=a("absolute"),D=a(" positioning, otherwise the [core-package][] script won\u2019t get correct dimentions;"),O=M(),o=h("li"),k=a("Using the "),E=h("code"),I=a("background"),P=a(" option usually is not recommended. In case you need to use it, specify the slide sizes with custom properties: "),y=h("code"),S=a("width"),j=a(" and "),b=h("code"),z=a("height"),L=a(", or just "),w=h("code"),U=a("aspect-ratio"),q=a("."),this.h()},l(r){e=p(r,"H2",{id:!0});var v=f(e);c=i(v,"Possible issues"),v.forEach(l),d=N(r),n=p(r,"UL",{});var x=f(n);t=p(x,"LI",{});var $=f(t);_=i($,"Slides should not have "),m=p($,"CODE",{});var F=f(m);C=i(F,"absolute"),F.forEach(l),D=i($," positioning, otherwise the [core-package][] script won\u2019t get correct dimentions;"),$.forEach(l),O=N(x),o=p(x,"LI",{});var u=f(o);k=i(u,"Using the "),E=p(u,"CODE",{});var H=f(E);I=i(H,"background"),H.forEach(l),P=i(u," option usually is not recommended. In case you need to use it, specify the slide sizes with custom properties: "),y=p(u,"CODE",{});var V=f(y);S=i(V,"width"),V.forEach(l),j=i(u," and "),b=p(u,"CODE",{});var G=f(b);z=i(G,"height"),G.forEach(l),L=i(u,", or just "),w=p(u,"CODE",{});var J=f(w);U=i(J,"aspect-ratio"),J.forEach(l),q=i(u,"."),u.forEach(l),x.forEach(l),this.h()},h(){ae(e,"id","possible-issues")},m(r,v){A(r,e,v),s(e,c),A(r,d,v),A(r,n,v),s(n,t),s(t,_),s(t,m),s(m,C),s(t,D),s(n,O),s(n,o),s(o,k),s(o,E),s(E,I),s(o,P),s(o,y),s(y,S),s(o,j),s(o,b),s(b,z),s(o,L),s(o,w),s(w,U),s(o,q)},p:ie,d(r){r&&l(e),r&&l(d),r&&l(n)}}}function re(g){let e,c;const d=[g[0]];let n={$$slots:{default:[le]},$$scope:{ctx:g}};for(let t=0;t<d.length;t+=1)n=B(n,d[t]);return e=new ne({props:n}),{c(){W(e.$$.fragment)},l(t){X(e.$$.fragment,t)},m(t,_){Y(e,t,_),c=!0},p(t,[_]){const m=_&1?Z(d,[ee(t[0])]):{};_&2&&(m.$$scope={dirty:_,ctx:t}),e.$set(m)},i(t){c||(te(e.$$.fragment,t),c=!0)},o(t){se(e.$$.fragment,t),c=!1},d(t){oe(e,t)}}}function ce(g,e,c){return g.$$set=d=>{c(0,e=B(B({},e),K(d)))},e=K(e),[e]}class he extends Q{constructor(e){super(),R(this,e,ce,re,T,{})}}export{he as default};
