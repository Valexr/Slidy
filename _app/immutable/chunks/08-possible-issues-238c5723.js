import{S as V,i as W,s as X,O as H,x as Y,y as Z,z as ee,R as te,a4 as K,f as se,t as oe,A as ae,U as M,k as h,q as a,a as N,l as p,m as f,r as i,h as n,c as Q,n as ie,b as A,D as s,C as le}from"./index-9fe0f8b0.js";import{P as ne}from"./Page-daaa1cb2.js";function ce(g){let e,d,u,l,t,c,m,C,D,O,o,k,E,P,I,b,S,U,y,j,z,w,L,q;return{c(){e=h("h2"),d=a("Possible issues"),u=N(),l=h("ul"),t=h("li"),c=a("Slides should not have "),m=h("code"),C=a("absolute"),D=a(" positioning, otherwise the [core-package][] script won’t get correct dimentions;"),O=N(),o=h("li"),k=a("Using the "),E=h("code"),P=a("background"),I=a(" option usually is not recommended. In case you need to use it, specify the slide sizes with custom properties: "),b=h("code"),S=a("width"),U=a(" and "),y=h("code"),j=a("height"),z=a(", or just "),w=h("code"),L=a("aspect-ratio"),q=a("."),this.h()},l(r){e=p(r,"H2",{id:!0});var v=f(e);d=i(v,"Possible issues"),v.forEach(n),u=Q(r),l=p(r,"UL",{});var x=f(l);t=p(x,"LI",{});var $=f(t);c=i($,"Slides should not have "),m=p($,"CODE",{});var R=f(m);C=i(R,"absolute"),R.forEach(n),D=i($," positioning, otherwise the [core-package][] script won’t get correct dimentions;"),$.forEach(n),O=Q(x),o=p(x,"LI",{});var _=f(o);k=i(_,"Using the "),E=p(_,"CODE",{});var B=f(E);P=i(B,"background"),B.forEach(n),I=i(_," option usually is not recommended. In case you need to use it, specify the slide sizes with custom properties: "),b=p(_,"CODE",{});var F=f(b);S=i(F,"width"),F.forEach(n),U=i(_," and "),y=p(_,"CODE",{});var G=f(y);j=i(G,"height"),G.forEach(n),z=i(_,", or just "),w=p(_,"CODE",{});var J=f(w);L=i(J,"aspect-ratio"),J.forEach(n),q=i(_,"."),_.forEach(n),x.forEach(n),this.h()},h(){ie(e,"id","possible-issues")},m(r,v){A(r,e,v),s(e,d),A(r,u,v),A(r,l,v),s(l,t),s(t,c),s(t,m),s(m,C),s(t,D),s(l,O),s(l,o),s(o,k),s(o,E),s(E,P),s(o,I),s(o,b),s(b,S),s(o,U),s(o,y),s(y,j),s(o,z),s(o,w),s(w,L),s(o,q)},p:le,d(r){r&&n(e),r&&n(u),r&&n(l)}}}function re(g){let e,d;const u=[g[0],T];let l={$$slots:{default:[ce]},$$scope:{ctx:g}};for(let t=0;t<u.length;t+=1)l=H(l,u[t]);return e=new ne({props:l}),{c(){Y(e.$$.fragment)},l(t){Z(e.$$.fragment,t)},m(t,c){ee(e,t,c),d=!0},p(t,[c]){const m=c&1?te(u,[c&1&&K(t[0]),c&0&&K(T)]):{};c&2&&(m.$$scope={dirty:c,ctx:t}),e.$set(m)},i(t){d||(se(e.$$.fragment,t),d=!0)},o(t){oe(e.$$.fragment,t),d=!1},d(t){ae(e,t)}}}const T={toc:[{level:2,title:"Possible issues",id:"possible-issues"}]};function de(g,e,d){return g.$$set=u=>{d(0,e=H(H({},e),M(u)))},e=M(e),[e]}class he extends V{constructor(e){super(),W(this,e,de,re,X,{})}}export{he as default,T as metadata};
